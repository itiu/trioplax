module libmongoc_headers;

private import std.stdio;

alias int bson_bool_t;

alias byte int8_t;
alias ubyte uint8_t;

alias short int16_t;
alias ushort uint16_t;

alias int int32_t;
alias uint uint32_t;

alias long int64_t;
alias ulong uint64_t;

public const static byte BSON_OK = 0;
public const static byte BSON_ERROR = -1;
public const static byte BSON_WARNING = -2;

public const static byte MONGO_OK = 0;
public const static byte MONGO_ERROR = -1;

enum mongo_error_t
{
	MONGO_CONN_SUCCESS = 0, /**< Connection success! */
	MONGO_CONN_NO_SOCKET, /**< Could not create a socket. */
	MONGO_CONN_FAIL, /**< An error occured while calling connect(). */
	MONGO_CONN_ADDR_FAIL, /**< An error occured while calling getaddrinfo(). */
	MONGO_CONN_NOT_MASTER, /**< Warning: connected to a non-master node (read-only). */
	MONGO_CONN_BAD_SET_NAME, /**< Given rs name doesn't match this replica set. */
	MONGO_CONN_NO_PRIMARY, /**< Can't find primary in replica set. Connection closed. */

	MONGO_IO_ERROR, /**< An error occurred while reading or writing on socket. */
	MONGO_READ_SIZE_ERROR, /**< The response is not the expected length. */
	MONGO_COMMAND_FAILED, /**< The command returned with 'ok' value of 0. */
	MONGO_CURSOR_EXHAUSTED, /**< The cursor has no more results. */
	MONGO_CURSOR_INVALID, /**< The cursor has timed out or is not recognized. */
	MONGO_CURSOR_PENDING, /**< Tailable cursor still alive but no data. */
	MONGO_BSON_INVALID, /**< BSON not valid for the specified op. */
	MONGO_BSON_NOT_FINISHED /**< BSON object has not been finished. */
};

string mongo_error_str[] = ["Connection success!", "Could not create a socket.",
		"An error occured while calling connect().", "An error occured while calling getaddrinfo().",
		"Warning: connected to a non-master node (read-only).", "Given rs name doesn't match this replica set.",
		"Can't find primary in replica set. Connection closed.",
		"An error occurred while reading or writing on socket.", "The response is not the expected length.",
		"The command returned with 'ok' value of 0.", "The cursor has no more results.",
		"The cursor has timed out or is not recognized.", "Tailable cursor still alive but no data.",
		"BSON not valid for the specified op.", "BSON object has not been finished."];

enum bson_type
{
	BSON_EOO = 0,
	BSON_DOUBLE = 1,
	BSON_STRING = 2,
	BSON_OBJECT = 3,
	BSON_ARRAY = 4,
	BSON_BINDATA = 5,
	BSON_UNDEFINED = 6,
	BSON_OID = 7,
	BSON_BOOL = 8,
	BSON_DATE = 9,
	BSON_NULL = 10,
	BSON_REGEX = 11,
	BSON_DBREF = 12, /**< Deprecated. */
	BSON_CODE = 13,
	BSON_SYMBOL = 14,
	BSON_CODEWSCOPE = 15,
	BSON_INT = 16,
	BSON_TIMESTAMP = 17,
	BSON_LONG = 18
};

extern(C)
	struct mongo_reply_fields
	{
		int flag; /* FIX THIS COMMENT non-zero on failure */
		int64_t cursorID;
		int start;
		int num;
	};

extern(C)
	struct mongo_header
	{
		int len;
		int id;
		int responseTo;
		int op;
	};

extern(C)
	struct mongo_reply
	{
		mongo_header head;
		mongo_reply_fields fields;
		char objs;
	};

extern(C)
	struct mongo_host_port
	{
		char host[255];
		int port;
		mongo_host_port* next;
	};

extern(C)
	struct mongo_replset
	{
		mongo_host_port* seeds; /**< List of seeds provided by the user. */
		mongo_host_port* hosts; /**< List of host/ports given by the replica set */
		char* name; /**< Name of the replica set. */
		bson_bool_t primary_connected; /**< Primary node connection status. */
	};

extern(C)
	struct mongo
	{
		mongo_host_port* primary; /**< Primary connection info. */
		mongo_replset* replset; /**< replset object if connected to a replica set. */
		int sock; /**< Socket file descriptor. */
		int flags; /**< Flags on this connection object. */
		int conn_timeout_ms; /**< Connection timeout in milliseconds. */
		int op_timeout_ms; /**< Read and write timeout in milliseconds. */
		bson_bool_t connected; /**< Connection status. */

		mongo_error_t err; /**< Most recent driver error code. */
		char* errstr; /**< String version of most recent driver error code. */
		int lasterrcode; /**< getlasterror given by the server on calls. */
		char* lasterrstr; /**< getlasterror string generated by server. */
	};

extern(C)
	struct bson
	{
		char* data;
		char* cur;
		int dataSize;
		bson_bool_t finished;
		int stack[32];
		int stackPos;
		int err; /**< Bitfield representing errors or warnings on this buffer */
		char* errstr; /**< A string representation of the most recent error or warning. */
	};

extern(C)
	struct mongo_cursor
	{
		mongo_reply* reply; /**< reply is owned by cursor */
		mongo* conn; /**< connection is *not* owned by cursor */
		const char* ns; /**< owned by cursor */
		int flags; /**< Flags used internally by this drivers. */
		int seen; /**< Number returned so far. */
		bson current; /**< This cursor's current bson object. */
		mongo_error_t err; /**< Errors on this cursor. */
		bson* query; /**< Bitfield containing cursor options. */
		bson* fields; /**< Bitfield containing cursor options. */
		int options; /**< Bitfield containing cursor options. */
		int limit; /**< Bitfield containing cursor options. */
		int skip; /**< Bitfield containing cursor options. */
	};

extern(C)
	struct bson_iterator
	{
		const char* cur;
		bson_bool_t first;
	};

extern(C)
	int mongo_cursor_destroy(mongo_cursor* cursor);

extern(C)
	int mongo_cursor_next(mongo_cursor* cursor);

extern(C)
	void bson_iterator_init(bson_iterator* i, bson* b);

extern(C)
	bson_type bson_iterator_next(bson_iterator* i);

extern(C)
	bson_type bson_iterator_type(bson_iterator* i);

extern(C)
	char* bson_iterator_key(bson_iterator* i);

extern(C)
	char* bson_iterator_string(bson_iterator* i);

extern(C)
	char* bson_iterator_value(const bson_iterator* i);

/**
 * Get a bson_iterator that on the BSON subobject.
 *
 * @param i the bson_iterator.
 * @param sub the iterator to point at the BSON subobject.
 */
extern(C)
	void bson_iterator_subiterator(bson_iterator* i, bson_iterator* sub);

/**
 * Connect to a single MongoDB server.
 *
 * @param conn a mongo object.
 * @param host a numerical network address or a network hostname.
 * @param port the port to connect to.
 *
 * @return MONGO_OK or MONGO_ERROR on failure. On failure, a constant of type
 *   mongo_conn_return_t will be set on the conn->err field.
 */
extern(C)
	int mongo_connect(mongo* conn, char* host, int port);

/**
 *  Initialize a new bson object. If not created
 *  with bson_new, you must initialize each new bson
 *  object using this function.
 *
 *  @note When finished, you must pass the bson object to
 *      bson_destroy( ).
 */
extern(C)
	void bson_init(bson* b);

/**
 * Remove a document from a MongoDB server.
 *
 * @param conn a mongo object.
 * @param ns the namespace.
 * @param cond the bson query.
 *
 * @return MONGO_OK or MONGO_ERROR with error stored in conn object.
 */
extern(C)
	int mongo_remove(mongo* conn, char* ns, bson* cond);

/**
 * Finalize a bson object.
 *
 * @param b the bson object to finalize.
 *
 * @return the standard error code. To deallocate memory,
 *   call bson_destroy on the bson object.
 */
extern(C)
	int bson_finish(bson* b);

/**
 * Destroy a bson object.
 *
 * @param b the bson object to destroy.
 *
 */
extern(C)
	void bson_destroy(bson* b);

/**
 * Find a single document in a MongoDB server.
 *
 * @param conn a mongo object.
 * @param ns the namespace.
 * @param query the bson query.
 * @param fields a bson document of the fields to be returned.
 * @param out a bson document in which to put the query result.
 *  
 */
/* out can be NULL if you don't care about results. useful for commands */
extern(C)
	bson_bool_t mongo_find_one(mongo* conn, char* ns, bson* query, bson* fields, bson* _out);

/**
 * Append a string to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the string.
 * @param str the string to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
//extern(C)
//	int bson_append_string(bson* b, const char* name, const char* str);
/**
 * Append len bytes of a string to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the string.
 * @param str the string to append.
 * @param len the number of bytes from str to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
//extern(C)
//	int bson_append_string_n(bson* b, char* name, char* str, int len);
/**
 * Find documents in a MongoDB server.
 *
 * @param conn a mongo object.
 * @param ns the namespace.
 * @param query the bson query.
 * @param fields a bson document of fields to be returned.
 * @param limit the maximum number of documents to retrun.
 * @param skip the number of documents to skip.
 * @param options A bitfield containing cursor options.
 *  
 * @return A cursor object allocated on the heap or NULL if
 *     an error has occurred. For finer-grained error checking,
 *     use the cursor builder API instead.
 */
extern(C)
	mongo_cursor* mongo_find(mongo* conn, char* ns, bson* query, bson* fields, int limit, int skip, int options);

/**
 * Start appending a new object to a bson.
 *
 * @param b the bson to append to.
 * @param name the name of the new object.
 *
 * @return BSON_OK or BSON_ERROR.
 */
//extern(C)
//	int bson_append_start_object(bson* b, char* name);
/**
 * Start appending a new array to a bson.
 *
 * @param b the bson to append to.
 * @param name the name of the new array.
 *
 * @return BSON_OK or BSON_ERROR.
 */
//extern(C)
//	int bson_append_start_array(bson* b, char* name);
/**
 * Append an int to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the int.
 * @param i the int to append.
 *
 * @return BSON_OK or BSON_ERROR.
 */
//extern(C)
//	int bson_append_int(bson* b, char* name, int i);
/**
 * Finish appending a new object or array to a bson.
 *
 * @param b the bson to append to.
 *
 * @return BSON_OK or BSON_ERROR.
 */
extern(C)
	int bson_append_finish_object(bson* b);

/**
 * Update a document in a MongoDB server.
 *
 * @param conn a mongo object.
 * @param ns the namespace.
 * @param cond the bson update query.
 * @param op the bson update data.
 * @param flags flags for the update.
 *
 * @return MONGO_OK or MONGO_ERROR with error stored in conn object.
 *
 */
extern(C)
	int mongo_update(mongo* conn, char* ns, const bson* cond, bson* op, int flags);

/**
 * Append a regex value to a bson.
 *
 * @param b the bson to append to.
 * @param name the key for the regex value.
 * @param pattern the regex pattern to append.
 * @param the regex options.
 *
 * @return BSON_OK or BSON_ERROR.
 */
//extern(C)
//	int bson_append_regex(bson* b, char* name, char* pattern, char* opts);
/** 
 * Get the int value of the BSON object currently pointed to by the iterator.
 *
 * @param i the bson_iterator
 *
 * @return  the value of the current BSON object.
 */
extern(C)
	int bson_iterator_int(bson_iterator* i);

/* these convert to the right type (return 0 if non-numeric) */
/**
 * Get the double value of the BSON object currently pointed to by the
 * iterator.
 *
 * @param i the bson_iterator
 *
 * @return  the value of the current BSON object.
 */
extern(C)
	double bson_iterator_double(bson_iterator* i);

/**
 * Get the boolean value of the BSON object currently pointed to by
 * the iterator.
 *
 * @param i the bson_iterator
 *
 * @return the value of the current BSON object.
 */
/* false: boolean false, 0 in any type, or null */
/* true: anything else (even empty strings and objects) */
extern(C)
	bson_bool_t bson_iterator_bool(bson_iterator* i);

/**
 * Get the value of the BSON regex object currently pointed to by the
 * iterator.
 *
 * @param i the bson_iterator
 *
 * @return the value of the current BSON regex object.
 */
extern(C)
	char* bson_iterator_regex(bson_iterator* i);

/**
 * Check that a string is valid UTF8. Sets the buffer bit field appropriately.
 *
 * @param b The bson object to which string will be appended.
 * @param string The string to check.
 * @param length The length of the string.
 *
 * @return BSON_OK if valid UTF-8; otherwise, BSON_ERROR.
 *     Sets b->err on error.
 */
extern(C)
	bson_bool_t bson_check_string(bson* b, const char* string, const int length);

extern(C)
	void bson_append32(bson* b, const void* data);

extern(C)
	void bson_append(bson* b, const void* data, int len);

extern(C)
	void bson_append_byte(bson* b, char c);

extern(C)
	int bson_ensure_space(bson* b, const int bytesNeeded);

/**
 * Check that a field name is valid UTF8, does not start with a '$',
 * and contains no '.' characters. Set bson bit field appropriately.
 * Note that we don't need to check for '\0' because we're using
 * strlen(3), which stops at '\0'.
 *
 * @param b The bson object to which field name will be appended.
 * @param string The field name as char*.
 * @param length The length of the field name.
 *
 * @return BSON_OK if valid UTF8 and BSON_ERROR if not. All BSON strings must be
 *     valid UTF8. This function will also check whether the string
 *     contains '.' or starts with '$', since the validity of this depends on context.
 *     Set the value of b->err appropriately.
 */
extern(C)
	int bson_check_field_name(bson* b, const char* string, const int length);

/**
 * This method is invoked when a non-fatal bson error is encountered.
 * Calls the error handler if available.
 *
 *  @param
 */
extern(C)
	void bson_builder_error(bson* b);

// ++ stringz -> string

static int _bson_append_string(bson* b, string name, string value)
{
	return _bson_append_string_base(b, name, value, bson_type.BSON_STRING);
}

static int _bson_append_string_base(bson* b, string name, string value, bson_type type)
{
	int sl = value.length + 1;
	if(bson_check_string(b, cast(char*) value, sl - 1) == BSON_ERROR)
		return BSON_ERROR;
	if(_bson_append_estart(b, type, name, 4 + sl) == BSON_ERROR)
	{
		return BSON_ERROR;
	}
	bson_append32(b, &sl);
	bson_append(b, cast(char*) value, sl - 1);
	bson_append_byte(b, cast(char) 0);
	return BSON_OK;
}

static int _bson_append_estart(bson* b, int type, string name, int dataSize)
{
	if(name is null)
		return BSON_ERROR;

	int len = name.length + 1;
	if(bson_ensure_space(b, 1 + len + dataSize) == BSON_ERROR)
	{
		return BSON_ERROR;
	}

	if(bson_check_field_name(b, cast(char*) name, len - 1) == BSON_ERROR)
	{
		bson_builder_error(b);
		return BSON_ERROR;
	}

	bson_append_byte(b, cast(char) type);
	bson_append(b, cast(char*) name, len - 1);
	bson_append_byte(b, cast(char) 0);
	return BSON_OK;
}

static const int zero = 0;

static int _bson_append_start_array(bson* b, string name)
{
	if(_bson_append_estart(b, bson_type.BSON_ARRAY, name, 5) == BSON_ERROR)
		return BSON_ERROR;
	b.stack[b.stackPos++] = b.cur - b.data;
	bson_append32(b, &zero);
	return BSON_OK;
}

static int _bson_append_int(bson* b, string name, const int i)
{
	if(_bson_append_estart(b, bson_type.BSON_INT, name, 4) == BSON_ERROR)
		return BSON_ERROR;
	bson_append32(b, &i);
	return BSON_OK;
}

static int _bson_append_start_object(bson* b, string name)
{
	if(_bson_append_estart(b, bson_type.BSON_OBJECT, name, 5) == BSON_ERROR)
		return BSON_ERROR;
	b.stack[b.stackPos++] = b.cur - b.data;
	bson_append32(b, &zero);
	return BSON_OK;
}

static int _bson_append_regex(bson* b, string name, string pattern, string opts)
{
	int plen = 1;
	if(pattern !is null)
		plen = pattern.length + 1;

	int olen = 1;
	if(opts !is null)
		olen = opts.length + 1;

	if(_bson_append_estart(b, bson_type.BSON_REGEX, name, plen + olen) == BSON_ERROR)
		return BSON_ERROR;

	if(bson_check_string(b, cast(char*) pattern, plen - 1) == BSON_ERROR)
		return BSON_ERROR;

	bson_append(b, cast(char*) pattern, plen - 1);
	bson_append_byte(b, cast(char) 0);
	bson_append(b, cast(char*) opts, olen - 1);
	bson_append_byte(b, cast(char) 0);

	return BSON_OK;
}
